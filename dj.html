<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>REQUESTS • David Charles Events</title>
<style>
  :root{
    --bg:#212121;
    --section:#363636;
    --subsection:#424242;
    --border:#2b2b2b;
    --ink:#f2f2f2;
    --muted:#bdbdbd;
    --accent:#1dcec9;   /* Mark as Played */
    --amber:#f7b731;    /* Mark as Unplayed */
    --danger:#ef4444;   /* Remove */
    --ring:rgba(255,255,255,.22);
    --radius:12px;
    --maxw:1100px;
  }

  @font-face{
    font-family:"Adventor";
    src:url("texgyreadventor-regular.otf") format("opentype");
    font-weight:400; font-style:normal; font-display:swap;
  }

  *{ box-sizing:border-box; }
  html,body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"Adventor", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }

  .wrap{ max-width:var(--maxw); margin:0 auto; padding:16px 14px 56px; }
  .page-title{ text-align:center; margin:8px 0 18px; letter-spacing:.06em; font-weight:800; font-size:clamp(22px,5.5vw,36px); }

  .panel{ background:var(--section); border:1px solid var(--border); border-radius:var(--radius); padding:14px; margin-bottom:14px; }

  .row{ display:grid; grid-template-columns:1fr auto auto; gap:10px; align-items:end; }
  @media (max-width:720px){ .row{ grid-template-columns:1fr; } }

  label{ display:block; font-size:14px; color:var(--muted); margin:0 0 6px; }
  select, button{
    height:46px; border-radius:12px; border:1px solid #3a3a3a; background:#2a2a2a; color:#fff;
    font-family:"Adventor", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    font-size:15px; cursor:pointer;
    transition:filter .15s ease, transform .06s ease, box-shadow .06s ease, background .15s ease;
  }
  select{ padding:0 12px; width:100%; }
  button:hover{ filter:brightness(1.05); }
  button:active{ transform:translateY(1px); box-shadow:inset 0 2px 0 rgba(0,0,0,.25); }

  .btn{ display:inline-flex; align-items:center; justify-content:center; padding:0 14px;
        box-shadow:0 2px 0 rgba(0,0,0,.35), 0 10px 18px rgba(0,0,0,.15); }
  .btn.refresh{ background:#2f2f2f; border-color:#3a3a3a; }
  .btn.played { background:var(--accent); border-color:var(--accent); color:#000; width:100%; }
  .btn.unplayed{ background:var(--amber); border-color:var(--amber); color:#000; width:100%; }
  .btn.names { background:#2f2f2f; border-color:#3a3a3a; color:#fff; width:100%; }
  .btn.remove{ background:var(--danger); border-color:var(--danger); color:#fff; width:100%; }
  .btn.small { height:38px; font-size:14px; border-radius:10px; }

  .pill{
    display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(45,212,191,.1);
    border:1px solid rgba(45,212,191,.35); color:#a7f3d0; font-size:12px;
  }

  .h2{ margin:6px 0 10px; font-size:18px; font-weight:800; letter-spacing:.03em; display:flex; align-items:center; justify-content:space-between; }
  .count-pill{ font-size:13px; color:#dcdcdc; opacity:.9; margin-left:8px; }

  .collapsible{ background:var(--subsection); border:1px solid var(--border); border-radius:12px; padding:10px; margin-top:6px; }
  .collapsible-header{ display:flex; align-items:center; justify-content:space-between; cursor:pointer; user-select:none; }
  .twist{ width:18px; height:18px; display:inline-grid; place-items:center; margin-left:8px; }
  .collapsible-body{ display:none; margin-top:10px; }
  .collapsible.open .collapsible-body{ display:block; }

  .list{ display:grid; gap:10px; }
  .card{
    background:var(--section); border:1px solid var(--border); border-radius:12px; padding:10px;
    display:grid; grid-template-columns:64px 1fr 180px; gap:12px; align-items:center;
  }
  @media (max-width:700px){
    .card{ grid-template-columns:64px 1fr; }
    .card .actions{ grid-column:1 / -1; display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  }

  .thumb{ width:64px; height:64px; border-radius:10px; background:#1f1f1f; object-fit:cover; display:block; }
  .meta{ min-width:0; }
  .title{ margin:0 0 2px; font-weight:800; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .sub{ margin:0; color:#e6e6e6; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  .names-box{ margin-top:6px; background:var(--subsection); border:1px solid var(--border); border-radius:10px; padding:6px 10px; display:none; }
  .names-box.open{ display:block; }
  .names-box ul{ margin:6px 0 0; padding-left:18px; }
  .names-box li{ margin:3px 0; color:#fafafa; font-size:13px; }

  .footer-line{ margin-top:10px; color:var(--muted); font-size:12px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="page-title">REQUESTS</div>

    <div class="panel">
      <div class="row">
        <div>
          <label for="eventSel">Select Your Event</label>
          <select id="eventSel"></select>
        </div>
        <button id="refreshBtn" class="btn refresh" type="button">Refresh</button>
      </div>
      <div id="eventPill" class="pill" style="margin-top:10px; display:none;"></div>
    </div>

    <div class="panel" id="requestsPanel">
      <div class="collapsible open" id="reqWrap">
        <div class="collapsible-header" data-target="reqBody">
          <div>Requests <span id="reqCount" class="count-pill">(0)</span></div>
          <div class="twist">▾</div>
        </div>
        <div id="reqBody" class="collapsible-body">
          <div id="reqList" class="list"></div>
        </div>
      </div>

      <div class="collapsible" id="playedWrap">
        <div class="collapsible-header" data-target="playedBody">
          <div>Played Songs <span id="playedCount" class="count-pill">(0)</span></div>
          <div class="twist">▸</div>
        </div>
        <div id="playedBody" class="collapsible-body">
          <div id="playedList" class="list"></div>
        </div>
      </div>

      <div class="collapsible" id="removedWrap">
        <div class="collapsible-header" data-target="removedBody">
          <div>Removed Songs <span id="removedCount" class="count-pill">(0)</span></div>
          <div class="twist">▸</div>
        </div>
        <div id="removedBody" class="collapsible-body">
          <div id="removedList" class="list"></div>
        </div>
      </div>

      <div class="collapsible" id="spamWrap" style="margin-top:6px;">
        <div class="collapsible-header" data-target="spamBody">
          <div>Spammed Requests <span id="spamCount" class="count-pill">(0)</span></div>
          <div class="twist">▸</div>
        </div>
        <div id="spamBody" class="collapsible-body">
          <div id="spamList" class="list"></div>
        </div>
      </div>

      <div class="footer-line" id="statusLine"></div>
    </div>
  </div>

<script>
/* ===== Config ===== */
const ENDPOINT_URL = 'https://script.google.com/macros/s/AKfycbxkSPUc2VWQYkhJ_af7CShegZLAMmVgUsTp2nMeVwkkhdFbdQT8wk2s6xBAAynjtLDT/exec';
const POLL_MS = 5000;

/* ===== Elements ===== */
const $ = s => document.querySelector(s);
const eventSel = $('#eventSel');
const refreshBtn = $('#refreshBtn');
const eventPill = $('#eventPill');

const reqList = $('#reqList');
const playedList = $('#playedList');
const removedList = $('#removedList');
const spamList = $('#spamList');

const reqCountEl = $('#reqCount');
const playedCountEl = $('#playedCount');
const removedCountEl = $('#removedCount');
const spamCountEl = $('#spamCount');
const statusLine = $('#statusLine');

/* ===== State ===== */
let currentCode = '';
let pollTimer = null;
let rowsCache = [];        // backend rows (raw)
const artCache = new Map();
const removedKeySet = new Set(); // client-side hidden “removed” songs (keyed by song|artist)

/* ===== Utilities ===== */
function jsonp(url, params = {}) {
  const qs = new URLSearchParams(params);
  const cb = 'cb_' + Math.random().toString(36).slice(2);
  qs.set('callback', cb);
  qs.set('t', Date.now());
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + qs.toString();
    const kill = setTimeout(() => { cleanup(); reject(new Error('timeout')); }, 9000);
    function cleanup(){ clearTimeout(kill); try{ delete window[cb]; }catch{} s.remove(); }
    window[cb] = (data) => { cleanup(); resolve(data); };
    s.onerror = () => { cleanup(); reject(new Error('jsonp error')); };
    document.body.appendChild(s);
  });
}
function keySong(song, artist){ return `${(song||'').toLowerCase()}|${(artist||'').toLowerCase()}`; }
function escapeHTML(s){ return String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function formatHeaderDate(iso){
  const d = new Date(iso); if (isNaN(d)) return '';
  const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  const yy = String(d.getFullYear()).slice(-2);
  return `${days[d.getDay()]} ${mm}.${dd}.${yy}`;
}
function checksum(rows){ let s=0; for(const r of rows){ s+= (r.id||'').length + (r.played?7:3);} return s+':'+rows.length; }

async function getArtwork(song, artist){
  const k = keySong(song, artist);
  if (artCache.has(k)) return artCache.get(k);
  try{
    const data = await jsonp('https://itunes.apple.com/search', { term:`${song} ${artist}`.trim(), entity:'musicTrack', limit:1 });
    const url = data?.results?.[0]?.artworkUrl100 || data?.results?.[0]?.artworkUrl60 || '';
    artCache.set(k, url||''); return url||'';
  }catch(_){ artCache.set(k,''); return ''; }
}

/* ===== Data loading ===== */
async function loadActiveEvents(){
  const res = await jsonp(ENDPOINT_URL, { mode:'listActive' });
  const list = Array.isArray(res?.events) ? res.events : [];
  eventSel.innerHTML = '';
  for (const ev of list){
    const opt = document.createElement('option');
    opt.value = ev.code;
    opt.textContent = `${formatHeaderDate(ev.date)} - ${ev.name}`;
    eventSel.appendChild(opt);
  }
  const urlp = new URLSearchParams(location.search);
  const pre = (urlp.get('event')||'').trim();
  if (pre && [...eventSel.options].some(o=>o.value===pre)) eventSel.value = pre;
  currentCode = eventSel.value || '';
  updateEventPill();
}

function startPolling(){ stopPolling(); pollTimer = setInterval(fetchRows, POLL_MS); }
function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

async function fetchRows(force=false){
  if (!currentCode) return;
  try{
    const res = await jsonp(ENDPOINT_URL, { mode:'read', event: currentCode });
    const rows = Array.isArray(res?.rows) ? res.rows : [];
    const changed = force || rows.length !== rowsCache.length || checksum(rows) !== checksum(rowsCache);
    rowsCache = rows;
    if (changed) renderAll(rows);
    statusLine.textContent = rows.length ? '' : 'No requests yet.';
  }catch(e){
    statusLine.textContent = 'Connection error. Try Refresh.';
  }
}

/* ===== Grouping ===== */
function splitBuckets(rows){
  const bySong = new Map();  // song|artist => {song, artist, ids:[], names:Set, anyPlayed, anyUnplayed, sampleRow}
  const spamMap = new Map(); // song|artist|name => count
  const playedRows = [];     // raw played rows

  for (const r of rows){
    const k = keySong(r.song_title, r.artist);
    if (!bySong.has(k)) bySong.set(k, { song:r.song_title||'', artist:r.artist||'', ids:[], names:new Set(), anyPlayed:false, anyUnplayed:false, sampleRow:r });
    const node = bySong.get(k);
    node.ids.push(r.id);
    if (r.name) node.names.add(r.name);
    if (r.played) node.anyPlayed = true; else node.anyUnplayed = true;
    if (r.played) playedRows.push(r);

    const kp = `${k}|${(r.name||'').toLowerCase()}`;
    spamMap.set(kp, (spamMap.get(kp)||0)+1);
  }

  const requests = [];
  for (const [k,node] of bySong.entries()){
    if (node.anyUnplayed){
      requests.push({
        key:k, song:node.song, artist:node.artist,
        ids: rows.filter(x=>keySong(x.song_title,x.artist)===k && !x.played).map(x=>x.id),
        people: [...node.names]
      });
    }
  }

  const played = [];
  for (const [k,node] of bySong.entries()){
    if (node.anyPlayed && !node.anyUnplayed){
      // fully played group (only for count in header)
      played.push({ key:k, song:node.song, artist:node.artist, ids: rows.filter(x=>keySong(x.song_title,x.artist)===k && x.played).map(x=>x.id), people:[...node.names] });
    }
  }

  const spam = [];
  for (const [kp,count] of spamMap.entries()){
    if (count>1){
      const [songLower, artistLower, nameLower] = kp.split('|');
      const row = rows.find(x => keySong(x.song_title,x.artist)===`${songLower}|${artistLower}` && String(x.name||'').toLowerCase()===nameLower);
      if (row){
        spam.push({ song:row.song_title, artist:row.artist, name:row.name, count });
      }
    }
  }

  return { requests, playedRows, played, spam };
}

/* ===== Card builders ===== */
function namesBoxHTML(names){
  const items = names.map(n=>`<li>${escapeHTML(n)}</li>`).join('');
  return `<div class="names-box"><div class="muted">Requesters:</div><ul>${items}</ul></div>`;
}

function buildRequestCard(obj){
  // obj: {key,song,artist,ids,people}
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.key = obj.key;
  card.dataset.ids = JSON.stringify(obj.ids);

  card.innerHTML = `
    <img class="thumb" alt="" />
    <div class="meta">
      <p class="title">${escapeHTML(obj.song||'Unknown Title')}</p>
      <p class="sub">${escapeHTML(obj.artist||'Unknown Artist')}</p>
      <p class="sub">${obj.people.length<=1 ? escapeHTML(obj.people[0]?`Requested by ${obj.people[0]}`:'Requested') : `Requested by (${obj.people.length}) people`}</p>
      ${obj.people.length>1 ? namesBoxHTML(obj.people) : `<div class="names-box"></div>`}
    </div>
    <div class="actions">
      <button class="btn played small" type="button">Mark as Played</button>
      <button class="btn names small" type="button">${obj.people.length>1?'Show names':'Show names'}</button>
      <button class="btn remove small" type="button">Remove</button>
    </div>
  `;

  // artwork async
  (async()=>{
    const img = card.querySelector('.thumb');
    const src = await getArtwork(obj.song, obj.artist);
    if (src){ img.src = src; img.alt = `${obj.song} cover`; }
  })();

  // names toggle
  const namesBtn = card.querySelector('.btn.names');
  const box = card.querySelector('.names-box');
  namesBtn.addEventListener('click', ()=>{
    box.classList.toggle('open');
    namesBtn.textContent = box.classList.contains('open') ? 'Hide names' : 'Show names';
  });

  // Mark as Played (optimistic move of the exact card)
  const playBtn = card.querySelector('.btn.played');
  playBtn.addEventListener('click', async ()=>{
    // move card as-is to played list
    reqList.removeChild(card);
    addPlayedCardFromRequestCard(card);
    updateCounts();
    // backend: set all its unplayed ids to played
    const ids = JSON.parse(card.dataset.ids||'[]');
    try{
      await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'true' })));
      fetchRows(true);
    }catch(e){
      // revert
      playedList.removeChild(card);
      reqList.appendChild(card);
      updateCounts();
    }
  });

  // Remove (client-side only)
  const rmBtn = card.querySelector('.btn.remove');
  rmBtn.addEventListener('click', ()=>{
    const k = card.dataset.key;
    removedKeySet.add(k);
    reqList.removeChild(card);
    addRemovedCardFromRequestCard(card);
    updateCounts();
  });

  return card;
}

function addPlayedCardFromRequestCard(requestCard){
  // convert the action buttons to include "Mark as Unplayed"
  const card = requestCard; // reuse
  card.querySelector('.actions').innerHTML = `
    <button class="btn unplayed small" type="button">Mark as Unplayed</button>
  `;

  // fast optimistic unplayed: move back immediately on click
  const unBtn = card.querySelector('.btn.unplayed');
  unBtn.addEventListener('click', async ()=>{
    playedList.removeChild(card);
    addRequestCardFromPlayedCard(card);  // move exact card back
    updateCounts();
    // backend: set ids to unplayed
    const ids = JSON.parse(card.dataset.ids||'[]');
    try{
      await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'false' })));
      fetchRows(true);
    }catch(e){
      // revert on failure
      reqList.removeChild(card);
      playedList.appendChild(card);
      updateCounts();
    }
  });

  playedList.appendChild(card);
}

function addRequestCardFromPlayedCard(playedCard){
  // rebuild actions to Played + Names + Remove
  const card = playedCard;
  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button class="btn played small" type="button">Mark as Played</button>
    <button class="btn names small" type="button">Show names</button>
    <button class="btn remove small" type="button">Remove</button>
  `;
  card.querySelector('.actions')?.replaceWith(actions);

  // wire buttons
  const namesBtn = actions.querySelector('.btn.names');
  const box = card.querySelector('.names-box');
  namesBtn.addEventListener('click', ()=>{
    box.classList.toggle('open');
    namesBtn.textContent = box.classList.contains('open') ? 'Hide names' : 'Show names';
  });

  const playBtn = actions.querySelector('.btn.played');
  playBtn.addEventListener('click', async ()=>{
    reqList.removeChild(card);
    addPlayedCardFromRequestCard(card);
    updateCounts();
    const ids = JSON.parse(card.dataset.ids||'[]');
    try{
      await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'true' })));
      fetchRows(true);
    }catch(e){
      playedList.removeChild(card);
      reqList.appendChild(card);
      updateCounts();
    }
  });

  const rmBtn = actions.querySelector('.btn.remove');
  rmBtn.addEventListener('click', ()=>{
    const k = card.dataset.key;
    removedKeySet.add(k);
    reqList.removeChild(card);
    addRemovedCardFromRequestCard(card);
    updateCounts();
  });

  reqList.appendChild(card);
}

function addRemovedCardFromRequestCard(requestCard){
  const card = requestCard;
  // For Removed, show Put Back only
  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `<button class="btn names small" type="button">Show names</button>
                       <button class="btn small" style="width:100%; background:#2f2f2f; border-color:#3a3a3a;" type="button">Put Back</button>`;
  card.querySelector('.actions')?.replaceWith(actions);

  // names toggle still works
  const namesBtn = actions.querySelector('.btn.names');
  const box = card.querySelector('.names-box');
  namesBtn.addEventListener('click', ()=>{
    box.classList.toggle('open');
    namesBtn.textContent = box.classList.contains('open') ? 'Hide names' : 'Show names';
  });

  const putBack = actions.querySelector('button:nth-of-type(2)');
  putBack.addEventListener('click', ()=>{
    const k = card.dataset.key;
    removedKeySet.delete(k);
    removedList.removeChild(card);
    addRequestCardFromRemovedCard(card);
    updateCounts();
  });

  removedList.appendChild(card);
}

function addRequestCardFromRemovedCard(removedCard){
  const card = removedCard;
  // restore Request actions
  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button class="btn played small" type="button">Mark as Played</button>
    <button class="btn names small" type="button">Show names</button>
    <button class="btn remove small" type="button">Remove</button>
  `;
  card.querySelector('.actions')?.replaceWith(actions);

  const namesBtn = actions.querySelector('.btn.names');
  const box = card.querySelector('.names-box');
  namesBtn.addEventListener('click', ()=>{
    box.classList.toggle('open');
    namesBtn.textContent = box.classList.contains('open') ? 'Hide names' : 'Show names';
  });

  const playBtn = actions.querySelector('.btn.played');
  playBtn.addEventListener('click', async ()=>{
    reqList.removeChild(card);
    addPlayedCardFromRequestCard(card);
    updateCounts();
    const ids = JSON.parse(card.dataset.ids||'[]');
    try{
      await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'true' })));
      fetchRows(true);
    }catch(e){
      playedList.removeChild(card);
      reqList.appendChild(card);
      updateCounts();
    }
  });

  const rmBtn = actions.querySelector('.btn.remove');
  rmBtn.addEventListener('click', ()=>{
    const k = card.dataset.key;
    removedKeySet.add(k);
    reqList.removeChild(card);
    addRemovedCardFromRequestCard(card);
    updateCounts();
  });

  reqList.appendChild(card);
}

/* ===== Render ===== */
function renderAll(rows){
  // Build groups
  const { requests, playedRows, played, spam } = splitBuckets(rows);

  // Requests (skip removed keys)
  reqList.innerHTML = '';
  for (const r of requests){
    if (removedKeySet.has(r.key)) continue;
    reqList.appendChild(buildRequestCard(r));
  }

  // Played (cards show as full song cards too)
  playedList.innerHTML = '';
  // Create unique groups that are fully/partly played to display cards
  const playedGroups = new Map();
  for (const pr of playedRows){
    const k = keySong(pr.song_title, pr.artist);
    if (!playedGroups.has(k)) playedGroups.set(k, { key:k, song:pr.song_title, artist:pr.artist, ids:[], people:new Set() });
    const g = playedGroups.get(k);
    g.ids.push(pr.id);
    if (pr.name) g.people.add(pr.name);
  }
  for (const [,g] of playedGroups.entries()){
    const card = buildRequestCard({ key:g.key, song:g.song, artist:g.artist, ids:g.ids, people:[...g.people] });
    // convert to Played card actions
    addPlayedCardFromRequestCard(card);
  }

  // Removed list remains as-is (client-side only)

  // Spam
  spamList.innerHTML = '';
  for (const s of spam){
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <img class="thumb" alt="" />
      <div class="meta">
        <p class="title">${escapeHTML(s.song || 'Unknown Title')}</p>
        <p class="sub">${escapeHTML(s.artist || 'Unknown Artist')}</p>
        <p class="sub">Requested by ${escapeHTML(s.name || 'Guest')} (x${s.count})</p>
      </div>
      <div class="actions"></div>
    `;
    (async()=>{
      const img = card.querySelector('.thumb');
      const src = await getArtwork(s.song, s.artist);
      if (src) { img.src = src; img.alt = `${s.song} cover`; }
    })();
    spamList.appendChild(card);
  }

  updateCounts();
}

function updateCounts(){
  reqCountEl.textContent     = `(${reqList.children.length})`;
  playedCountEl.textContent  = `(${playedList.children.length})`;
  removedCountEl.textContent = `(${removedList.children.length})`;
  spamCountEl.textContent    = `(${spamList.children.length})`;
}

/* ===== Collapsibles ===== */
function initCollapsibles(){
  document.querySelectorAll('.collapsible-header').forEach(h=>{
    h.addEventListener('click', ()=>{
      const parent = h.parentElement;
      parent.classList.toggle('open');
      const twist = h.querySelector('.twist');
      if (twist) twist.textContent = parent.classList.contains('open') ? '▾' : '▸';
    });
  });
}

/* ===== Misc ===== */
function updateEventPill(){
  if (currentCode){
    eventPill.style.display = 'inline-block';
    eventPill.textContent = `Event = ${currentCode}`;
  }else{
    eventPill.style.display = 'none';
    eventPill.textContent = '';
  }
}

/* ===== Init ===== */
eventSel.addEventListener('change', ()=>{
  currentCode = eventSel.value || '';
  updateEventPill();
  removedKeySet.clear(); // reset client-side removed set when switching events
  fetchRows(true);
  startPolling();
});
refreshBtn.addEventListener('click', ()=> fetchRows(true));

(async function boot(){
  const urlp = new URLSearchParams(location.search);
  const pre = (urlp.get('event')||'').trim();

  await loadActiveEvents();
  if (pre && [...eventSel.options].some(o=>o.value===pre)) {
    eventSel.value = pre; currentCode = pre; updateEventPill();
  }
  initCollapsibles();
  await fetchRows(true);
  startPolling();
})();
</script>
</body>
</html>

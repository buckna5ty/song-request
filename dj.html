<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>REQUESTS • David Charles Events</title>
<style>
  :root{
    --bg:#212121;
    --section:#363636;
    --subsection:#424242;
    --border:#2b2b2b;
    --ink:#f2f2f2;
    --muted:#bdbdbd;

    --accent:#1dcec9;    /* Mark as Played */
    --amber:#f7b731;     /* Mark as Unplayed */
    --names:#1a2d6b;     /* Show/Hide Names (navy-ish) */
    --danger:#b22222;    /* Remove (darker red) */
    --put:#d81b60;       /* Put Back (dark pink) */

    --radius:12px;
    --maxw:1100px;

    --anim-ms:320ms;
    --anim-ease:cubic-bezier(.22,.61,.36,1);
  }

  @font-face{
    font-family:"Adventor";
    src:url("texgyreadventor-regular.otf") format("opentype");
    font-weight:400; font-style:normal; font-display:swap;
  }

  *{ box-sizing:border-box; }
  html,body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"Adventor", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .wrap{ max-width:var(--maxw); margin:0 auto; padding:16px 14px 56px; }
  .page-title{
    text-align:center; margin:8px 0 18px;
    letter-spacing:.06em; font-weight:800;
    font-size:clamp(22px,5.5vw,36px);
  }

  /* Panels */
  .panel{
    background:var(--section);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:14px;
    margin-bottom:14px;
  }
  label{
    display:block; font-size:14px; color:var(--muted); margin:0 0 6px;
  }
  select{
    height:46px; border-radius:12px; border:1px solid #3a3a3a;
    background:#2a2a2a; color:#fff; font-size:15px; padding:0 12px; width:100%;
  }

  .inline-info{
    margin-top:8px;
    font-size:14px;
    min-height:22px; /* reserve space */
    font-weight:500;
    color:#e7e7e7;
  }
  .inline-info.good{ color:#34d399; } /* green */
  .inline-info.bad{  color:#ef4444; } /* red */

  /* Folder-style tabs */
  .tabs-wrap{ margin-bottom:12px; }
  .tabs-bar{
    display:flex; gap:0; align-items:flex-end;
    border-bottom:1px solid var(--border);
    padding:0 6px;
  }
  .tab-btn{
    appearance:none; cursor:pointer;
    height:36px; padding:0 14px; font-size:13px; line-height:1; color:#fff;
    background:#2f2f2f; border:1px solid var(--border); border-bottom:none;
    border-top-left-radius:10px; border-top-right-radius:10px;
    margin:0 6px; transform:translateY(1px);
    transition:filter .15s ease, transform .06s ease;
  }
  .tab-btn:hover{ filter:brightness(1.05); }
  .tab-btn:active{ transform:translateY(2px); }
  .tab-btn.active{ background:var(--subsection); transform:translateY(0); }

  .hidden{ display:none !important; }

  /* Collapsibles */
  .collapsible{
    background:var(--subsection);
    border:1px solid var(--border);
    border-radius:12px;
    padding:10px;
    margin-top:10px;
  }
  .collapsible-header{
    display:flex; align-items:center; justify-content:space-between;
    cursor:pointer; user-select:none;
  }
  .twist{ width:18px; height:18px; display:inline-grid; place-items:center; margin-left:8px; }
  .collapsible-body{ display:none; margin-top:10px; }
  .collapsible.open .collapsible-body{ display:block; }

  .h2{
    margin:6px 0 10px; font-size:18px; font-weight:800; letter-spacing:.03em;
    display:flex; align-items:center; justify-content:space-between;
  }
  .count-pill{ font-size:13px; color:#dcdcdc; opacity:.9; margin-left:8px; }

  .list{ display:grid; gap:10px; position:relative; }

  .card{
    background:var(--section);
    border:1px solid var(--border);
    border-radius:12px;
    padding:10px;

    display:grid;
    grid-template-columns:64px 1fr 190px;
    gap:12px; align-items:center;

    /* FLIP animation */
    will-change: transform, opacity;
    transition: transform var(--anim-ms) var(--anim-ease), opacity var(--anim-ms) var(--anim-ease);
  }
  @media (max-width:760px){
    .card{ grid-template-columns:64px 1fr; }
    .card .actions{ grid-column:1 / -1; }
  }

  .thumb{
    width:64px;height:64px;border-radius:10px;background:#1f1f1f;object-fit:cover;display:block;
  }
  .meta{ min-width:0; }
  .title{
    margin:0 0 2px; font-weight:800; font-size:16px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#fff;
  }
  .sub{
    margin:0; color:#e6e6e6; font-size:13px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  .actions{ display:grid; gap:6px; }

  /* compact buttons */
  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    padding:0 10px; height:32px; font-size:12px; line-height:1;
    border-radius:8px; border:1px solid transparent;
    box-shadow:0 2px 0 rgba(0,0,0,.35), 0 8px 14px rgba(0,0,0,.15);
    width:82%; margin:0 auto;
    transition:filter .15s ease, transform .06s ease, background .15s ease, box-shadow .06s ease;
    cursor:pointer; font-weight:600; color:#000;
  }
  .btn:hover{ filter:brightness(1.05); }
  .btn:active{ transform:translateY(1px); box-shadow:inset 0 2px 0 rgba(0,0,0,.25); }

  .btn.played   { background:var(--accent);  border-color:var(--accent);  color:#000; }
  .btn.unplayed { background:var(--amber);   border-color:var(--amber);   color:#000; }
  .btn.names    { background:var(--names);   border-color:var(--names);   color:#fff; }
  .btn.remove   { background:var(--danger);  border-color:var(--danger);  color:#fff; }
  .btn.putback  { background:var(--put);     border-color:var(--put);     color:#fff; }

  .names-box{
    margin-top:6px; background:var(--subsection);
    border:1px solid var(--border); border-radius:10px; padding:8px 10px; display:none;
  }
  .names-box.open{ display:block; }
  .names-box .hdr{ color:#cfcfcf; font-size:13px; margin:0 0 4px; }
  .names-box ul{ margin:0; padding-left:18px; }
  .names-box li{ margin:3px 0; color:#fafafa; font-size:13px; }

  .footer-line{ margin-top:10px; color:#fff; font-size:12px; }

  /* enter/exit helpers */
  .enter{ opacity:0; transform:translateY(8px); }
  .enter-active{ opacity:1; transform:none; }
  .exit{ opacity:1; transform:none; }
  .exit-active{ opacity:0; transform:translateY(-8px); }
</style>
</head>
<body>
  <div class="wrap">
    <div class="page-title">REQUESTS</div>

    <!-- Event chooser -->
    <div class="panel">
      <label for="eventSel">Select Your Event</label>
      <select id="eventSel"></select>
      <div id="inlineInfo" class="inline-info" aria-live="polite"></div>
    </div>

    <!-- Tabs + content -->
    <div class="panel">
      <div class="tabs-wrap">
        <div class="tabs-bar">
          <button id="tabRequests" class="tab-btn active" type="button">Requests</button>
          <button id="tabSpam" class="tab-btn" type="button">Spam</button>
        </div>
      </div>

      <!-- Requests tab -->
      <div id="tabRequestsPane">
        <div class="collapsible open" id="reqWrap">
          <div class="collapsible-header" data-target="reqBody">
            <div>Requests <span id="reqCount" class="count-pill">(0)</span></div>
            <div class="twist">▾</div>
          </div>
          <div id="reqBody" class="collapsible-body">
            <div id="reqList" class="list"></div>
          </div>
        </div>

        <div class="collapsible" id="playedWrap">
          <div class="collapsible-header" data-target="playedBody">
            <div>Played Songs <span id="playedCount" class="count-pill">(0)</span></div>
            <div class="twist">▸</div>
          </div>
          <div id="playedBody" class="collapsible-body">
            <div id="playedList" class="list"></div>
          </div>
        </div>

        <div class="collapsible" id="removedWrap">
          <div class="collapsible-header" data-target="removedBody">
            <div>Removed Songs <span id="removedCount" class="count-pill">(0)</span></div>
            <div class="twist">▸</div>
          </div>
          <div id="removedBody" class="collapsible-body">
            <div id="removedList" class="list"></div>
          </div>
        </div>

        <div class="footer-line" id="statusLine"></div>
      </div>

      <!-- Spam tab -->
      <div id="tabSpamPane" class="hidden">
        <div class="h2">
          Spammed Requests
          <span id="spamCountTop" class="count-pill">(0)</span>
        </div>
        <div id="spamList" class="list"></div>
      </div>
    </div>
  </div>

<script>
/* ===== Config ===== */
const ENDPOINT_URL = 'https://script.google.com/macros/s/AKfycbxkSPUc2VWQYkhJ_af7CShegZLAMmVgUsTp2nMeVwkkhdFbdQT8wk2s6xBAAynjtLDT/exec';
const POLL_MS = 5000;

/* ===== Elements ===== */
const $ = s => document.querySelector(s);
const eventSel      = $('#eventSel');
const inlineInfo    = $('#inlineInfo');

const tabRequestsBtn = $('#tabRequests');
const tabSpamBtn     = $('#tabSpam');
const tabRequestsPane= $('#tabRequestsPane');
const tabSpamPane    = $('#tabSpamPane');

const reqList       = $('#reqList');
const playedList    = $('#playedList');
const removedList   = $('#removedList');
const spamList      = $('#spamList');

const reqCountEl    = $('#reqCount');
const playedCountEl = $('#playedCount');
const removedCountEl= $('#removedCount');
const spamCountTop  = $('#spamCountTop');
const statusLine    = $('#statusLine');

/* ===== State ===== */
let currentCode = '';
let pollTimer   = null;
let rowsCache   = [];          // latest rows from backend
const artCache      = new Map();
const removedKeySet = new Set(); // local-only "removed" by song key

/* ===== utils ===== */
function pad2(n){ return String(n).padStart(2,'0'); }
function dow3(n){ return ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][n] || ''; }
function formatHeaderDate(dateStr){
  try{
    const d = new Date(dateStr);
    if (isNaN(d)) return '';
    return `${dow3(d.getDay())} ${pad2(d.getMonth()+1)}.${pad2(d.getDate())}.${String(d.getFullYear()).slice(-2)}`;
  }catch{ return ''; }
}
function showInline(msg){
  inlineInfo.textContent = msg || '';
  inlineInfo.classList.remove('good','bad');
  if (!msg) return;
  const lower = msg.toLowerCase();
  if (lower.startsWith('loading')) inlineInfo.classList.add('good');
  else if (lower.includes('could not load')) inlineInfo.classList.add('bad');
}
function keySong(song, artist){ return `${(song||'').toLowerCase()}|${(artist||'').toLowerCase()}`; }
function escapeHTML(s){ return String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function checksum(rows){ let s=0; for(const r of rows){ s+= (r.id||'').length + (r.played?7:3);} return s+':'+rows.length; }

/* JSONP helper */
function jsonp(url, params = {}) {
  const qs = new URLSearchParams(params);
  const cb = 'cb_' + Math.random().toString(36).slice(2);
  qs.set('callback', cb);
  qs.set('t', Date.now());
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = url + (url.includes('?') ? '&' : '?') + qs.toString();
    const kill = setTimeout(() => { cleanup(); reject(new Error('timeout')); }, 9000);
    function cleanup(){ clearTimeout(kill); try{ delete window[cb]; }catch{} s.remove(); }
    window[cb] = (data) => { cleanup(); resolve(data); };
    s.onerror = () => { cleanup(); reject(new Error('jsonp error')); };
    document.body.appendChild(s);
  });
}

/* artwork via iTunes */
async function getArtwork(song, artist){
  const k = keySong(song, artist);
  if (artCache.has(k)) return artCache.get(k);
  try{
    const data = await jsonp('https://itunes.apple.com/search', { term:`${song} ${artist}`.trim(), entity:'musicTrack', limit:1 });
    const url = data?.results?.[0]?.artworkUrl100 || data?.results?.[0]?.artworkUrl60 || '';
    artCache.set(k, url||''); return url||'';
  }catch(_){ artCache.set(k,''); return ''; }
}

/* ===== Event loading ===== */
async function loadActiveEvents(){
  showInline('Loading your events...');
  try{
    const res  = await jsonp(ENDPOINT_URL, { mode:'listActive' });
    const list = Array.isArray(res?.events) ? res.events : [];
    list.sort((a,b)=> new Date(a.date||0) - new Date(b.date||0));

    eventSel.innerHTML = '';
    if (!list.length){
      const opt=document.createElement('option');
      opt.value=''; opt.textContent='No active events';
      eventSel.appendChild(opt);
      currentCode='';
      showInline('Could not load events.');
      return;
    }

    for (const ev of list){
      const opt = document.createElement('option');
      opt.value = ev.code;
      const d = formatHeaderDate(ev.date);
      opt.textContent = d ? `${d} - ${ev.name}` : (ev.name || ev.code);
      eventSel.appendChild(opt);
    }

    const urlp = new URLSearchParams(location.search);
    const pre  = (urlp.get('event')||'').trim();
    if (pre && [...eventSel.options].some(o=>o.value===pre)){ eventSel.value = pre; }

    currentCode = eventSel.value || '';
    showInline('');
  }catch(e){
    showInline('Could not load events.');
  }
}

/* ===== Polling & fetch ===== */
function startPolling(){ stopPolling(); pollTimer = setInterval(fetchRows, POLL_MS); }
function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

async function fetchRows(force=false){
  if (!currentCode) return;
  showInline('Loading your requests...');
  try{
    const res  = await jsonp(ENDPOINT_URL, { mode:'read', event: currentCode });
    const rows = Array.isArray(res?.rows) ? res.rows : [];
    const changed = force || rows.length !== rowsCache.length || checksum(rows) !== checksum(rowsCache);
    rowsCache = rows;
    if (changed) renderAll(rows);           // animate resort here
    statusLine.textContent = rows.length ? '' : 'No requests yet.';
  }catch(e){
    statusLine.textContent = 'Connection error.';
  }finally{
    showInline('');
  }
}

/* ===== Grouping logic ===== */
function splitBuckets(rows){
  const bySong    = new Map();
  const spamMap   = new Map();
  const playedArr = [];

  for (const r of rows){
    const song   = r.song_title || r.song || '';
    const artist = r.artist || '';
    const k      = keySong(song, artist);

    if (!bySong.has(k)){
      bySong.set(k, { song, artist, ids:[], names:new Set(), anyPlayed:false, anyUnplayed:false });
    }
    const node = bySong.get(k);
    node.ids.push(r.id);
    if (r.name) node.names.add(r.name);

    if (r.played){ node.anyPlayed = true; playedArr.push(r); }
    else{ node.anyUnplayed = true; }

    const kp = `${k}|${(r.name||'').toLowerCase()}`;
    spamMap.set(kp, (spamMap.get(kp)||0)+1);
  }

  const requests = [];
  for (const [k,node] of bySong.entries()){
    if (node.anyUnplayed){
      requests.push({
        key:k,
        song:node.song,
        artist:node.artist,
        ids:   rows.filter(x=>keySong(x.song_title||x.song,x.artist)===k && !x.played).map(x=>x.id),
        people:[...node.names]
      });
    }
  }

  const playedGroups = new Map();
  for (const pr of playedArr){
    const k = keySong(pr.song_title||pr.song, pr.artist);
    if (!playedGroups.has(k)){
      playedGroups.set(k, { key:k, song:pr.song_title||pr.song, artist:pr.artist, ids:[], people:new Set() });
    }
    const g = playedGroups.get(k);
    g.ids.push(pr.id);
    if (pr.name) g.people.add(pr.name);
  }

  const spam = [];
  for (const [kp,count] of spamMap.entries()){
    if (count>1){
      const [songLower, artistLower, nameLower] = kp.split('|');
      const anyRow = rows.find(x =>
        keySong(x.song_title||x.song,x.artist)===`${songLower}|${artistLower}` &&
        String(x.name||'').toLowerCase()===nameLower
      );
      if (anyRow){
        spam.push({ song:anyRow.song_title||anyRow.song, artist:anyRow.artist, name:anyRow.name, count });
      }
    }
  }

  return { requests, playedGroups:[...playedGroups.values()], spam };
}

/* ===== FLIP helpers for animated reordering ===== */
function measurePositions(container){
  const map = new Map();
  Array.from(container.children).forEach(el=>{
    if (el.classList.contains('card')){
      map.set(el.dataset.key, el.getBoundingClientRect());
    }
  });
  return map;
}

function flipAnimate(container, firstPos){
  const children = Array.from(container.children).filter(el=>el.classList.contains('card'));
  children.forEach(el=>{
    const last = el.getBoundingClientRect();
    const first = firstPos.get(el.dataset.key);
    if (!first) {
      // entering element
      el.classList.add('enter');
      void el.offsetWidth; // force
      el.classList.add('enter-active');
      el.addEventListener('transitionend', ()=>{
        el.classList.remove('enter','enter-active');
      }, {once:true});
      return;
    }
    const dx = first.left - last.left;
    const dy = first.top  - last.top;
    if (dx || dy){
      el.style.transform = `translate(${dx}px, ${dy}px)`;
      el.getBoundingClientRect(); // reflow
      el.style.transition = `transform var(--anim-ms) var(--anim-ease)`;
      el.style.transform = `translate(0,0)`;
      el.addEventListener('transitionend', ()=>{
        el.style.transition=''; el.style.transform='';
      }, {once:true});
    }
  });
}

function diffReorder(container, items, keyFn, upsert){
  const first = measurePositions(container);

  const existing = new Map();
  Array.from(container.children).forEach(el=>{
    if (el.classList.contains('card')) existing.set(el.dataset.key, el);
  });

  const desiredKeys = new Set(items.map(it=>keyFn(it)));

  // remove cards that no longer exist (fade out)
  existing.forEach((node, key)=>{
    if (!desiredKeys.has(key)){
      node.classList.add('exit');
      node.getBoundingClientRect();
      node.classList.add('exit-active');
      node.addEventListener('transitionend', ()=> node.remove(), {once:true});
    }
  });

  // add/update in desired order
  const frag = document.createDocumentFragment();
  for (const it of items){
    const k = keyFn(it);
    let node = existing.get(k);
    if (node){
      upsert(node, it);
    }else{
      node = upsert(null, it);
      node.classList.add('enter'); // animate in
    }
    frag.appendChild(node);
  }

  container.appendChild(frag);
  requestAnimationFrame(()=> flipAnimate(container, first));
}

/* ===== card builders/updaters ===== */
function namesBoxHTML(names){
  const items = names.map(n=>`<li>${escapeHTML(n)}</li>`).join('');
  return `<div class="names-box"><p class="hdr">Requesters</p><ul>${items}</ul></div>`;
}
async function setThumb(imgEl, song, artist){
  const src = await getArtwork(song, artist);
  if (src){ imgEl.src = src; imgEl.alt = `${song} cover`; }
}
function wireShowHideNames(card){
  const namesBtn = card.querySelector('.btn.names');
  const box      = card.querySelector('.names-box');
  if (!namesBtn || !box) return;
  namesBtn.addEventListener('click', ()=>{
    box.classList.toggle('open');
    namesBtn.textContent = box.classList.contains('open') ? 'Hide Names' : 'Show Names';
  });
}

function buildBaseCard({key,song,artist,ids,people}){
  const guestsCount = people.length || 0;
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.key = key;
  card.dataset.ids = JSON.stringify(ids);
  card.innerHTML = `
    <img class="thumb" alt="" />
    <div class="meta">
      <p class="title">${escapeHTML(song||'Unknown Title')}</p>
      <p class="sub">${escapeHTML(artist||'Unknown Artist')}</p>
      <p class="sub req-count">Requested by ${guestsCount} guest${guestsCount===1?'':'s'}</p>
      ${namesBoxHTML(people)}
    </div>
    <div class="actions"></div>
  `;
  setThumb(card.querySelector('.thumb'), song, artist);
  return card;
}

function updateBaseCard(node, {song,artist,ids,people}){
  node.dataset.ids = JSON.stringify(ids);
  node.querySelector('.title').textContent = song || 'Unknown Title';
  node.querySelector('.sub').textContent   = artist || 'Unknown Artist';
  const countEl = node.querySelector('.req-count');
  const guestsCount = people.length || 0;
  countEl.textContent = `Requested by ${guestsCount} guest${guestsCount===1?'':'s'}`;

  const box = node.querySelector('.names-box');
  if (box){
    box.innerHTML = `<p class="hdr">Requesters</p><ul>${people.map(n=>`<li>${escapeHTML(n)}</li>`).join('')}</ul>`;
  }
}

function addRequestButtons(card){
  const actions = card.querySelector('.actions');
  actions.innerHTML = `
    <button class="btn played"   type="button">Mark as Played</button>
    <button class="btn names"    type="button">Show Names</button>
    <button class="btn remove"   type="button">Remove</button>
  `;
  wireShowHideNames(card);

  const playBtn = actions.querySelector('.btn.played');
  playBtn.addEventListener('click', async ()=>{
    // optimistic local update: set rowsCache played=true for these ids
    const ids = JSON.parse(card.dataset.ids||'[]');
    setRowsPlayed(ids, true);          // <— immediate local resort/animate
    // backend write (fire-and-forget)
    try{ await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'true' }))); }
    catch(_e){}
  });

  const rmBtn = actions.querySelector('.btn.remove');
  rmBtn.addEventListener('click', ()=>{
    removedKeySet.add(card.dataset.key);
    resortRequestsOnly();              // <— re-render/animate after removal
  });
}

function addPlayedButtons(card){
  const actions = card.querySelector('.actions');
  actions.innerHTML = `
    <button class="btn unplayed" type="button">Mark as Unplayed</button>
    <button class="btn names"    type="button">Show Names</button>
  `;
  wireShowHideNames(card);

  const unBtn = actions.querySelector('.btn.unplayed');
  unBtn.addEventListener('click', async ()=>{
    const ids = JSON.parse(card.dataset.ids||'[]');
    setRowsPlayed(ids, false);         // <— immediate local resort/animate
    try{ await Promise.all(ids.map(id => jsonp(ENDPOINT_URL, { mode:'setPlayed', id, played:'false' }))); }
    catch(_e){}
  });
}

function addRemovedButtons(card){
  const actions = card.querySelector('.actions');
  actions.innerHTML = `
    <button class="btn putback" type="button">Put Back</button>
    <button class="btn names"   type="button">Show Names</button>
  `;
  wireShowHideNames(card);

  const putBtn = actions.querySelector('.btn.putback');
  putBtn.addEventListener('click', ()=>{
    removedKeySet.delete(card.dataset.key);
    resortRequestsOnly();              // <— immediate local resort/animate
  });
}

/* Build / update nodes for FLIP */
function upsertRequestNode(node, item){
  if (!node){
    node = buildBaseCard(item);
    addRequestButtons(node);
  }else{
    updateBaseCard(node, item);
  }
  return node;
}
function buildPlayedCard(obj){
  const card = buildBaseCard(obj);
  addPlayedButtons(card);
  return card;
}
function buildSpamCard(s){
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
    <img class="thumb" alt="" />
    <div class="meta">
      <p class="title">${escapeHTML(s.song||'Unknown Title')}</p>
      <p class="sub">${escapeHTML(s.artist||'Unknown Artist')}</p>
      <p class="sub">Requested by ${escapeHTML(s.name||'Guest')} (x${s.count})</p>
    </div>
    <div class="actions"></div>
  `;
  setThumb(card.querySelector('.thumb'), s.song, s.artist);
  return card;
}

/* ===== Rendering ===== */
function renderAll(rows){
  const { requests, playedGroups, spam } = splitBuckets(rows);

  // sort requests by #people desc, then alpha by song
  const sortedReqs = requests
    .map(r => ({...r, peopleCount:r.people.length}))
    .sort((a,b)=> b.peopleCount - a.peopleCount || (a.song||'').localeCompare(b.song||''));

  // Animate reorder in reqList via FLIP
  diffReorder(
    reqList,
    sortedReqs,
    (it)=> it.key,
    (node,it)=> upsertRequestNode(node, it)
  );

  // Played (rebuild; count is the only important thing)
  playedList.innerHTML = '';
  for (const g of playedGroups){
    const card = buildPlayedCard({ key:g.key, song:g.song, artist:g.artist, ids:g.ids, people:[...g.people] });
    playedList.appendChild(card);
  }

  // Spam
  spamList.innerHTML = '';
  for (const s of spam){
    spamList.appendChild(buildSpamCard(s));
  }

  updateCounts();
}
function updateCounts(){
  reqCountEl.textContent     = `(${reqList.children.length})`;
  playedCountEl.textContent  = `(${playedList.children.length})`;
  removedCountEl.textContent = `(${removedList.children.length})`;
  spamCountTop.textContent   = `(${spamList.children.length})`;
}

/* ===== Local-mutating helpers (instant UI resort) ===== */
function setRowsPlayed(ids, playedBool){
  // mutate rowsCache to reflect local action
  let touched = false;
  rowsCache = rowsCache.map(r=>{
    if (ids.includes(r.id)){
      touched = true;
      return {...r, played: !!playedBool};
    }
    return r;
  });
  if (touched) renderAll(rowsCache);
}

function resortRequestsOnly(){
  // Just re-render from current rowsCache and local removed set
  renderAll(rowsCache);
}

/* ===== collapsibles & tabs ===== */
function initCollapsibles(){
  document.querySelectorAll('.collapsible-header').forEach(h=>{
    h.addEventListener('click', ()=>{
      const parent = h.parentElement;
      parent.classList.toggle('open');
      const twist = h.querySelector('.twist');
      if (twist){ twist.textContent = parent.classList.contains('open') ? '▾' : '▸'; }
    });
  });
}
function setTab(which){
  if (which==='spam'){
    tabSpamBtn.classList.add('active'); tabRequestsBtn.classList.remove('active');
    tabSpamPane.classList.remove('hidden'); tabRequestsPane.classList.add('hidden');
  }else{
    tabRequestsBtn.classList.add('active'); tabSpamBtn.classList.remove('active');
    tabRequestsPane.classList.remove('hidden'); tabSpamPane.classList.add('hidden');
  }
}
tabRequestsBtn.addEventListener('click', ()=> setTab('requests'));
tabSpamBtn.addEventListener('click', ()=> setTab('spam'));

/* ===== init ===== */
eventSel.addEventListener('change', ()=>{
  currentCode = eventSel.value || '';
  removedKeySet.clear();
  fetchRows(true);
  startPolling();
});

(async function boot(){
  await loadActiveEvents();
  initCollapsibles();
  if (eventSel.value){
    currentCode = eventSel.value;
    await fetchRows(true);
    startPolling();
  }
})();
</script>
</body>
</html>
